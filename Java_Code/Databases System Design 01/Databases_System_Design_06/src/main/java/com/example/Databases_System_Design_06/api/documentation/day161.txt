ğŸ”¥ PART 1 â€” Redis Caching in Spring Boot (Proper Way)

In Spring Boot, we donâ€™t manually call Redis for caching most of the time.

We use:

@Cacheable
@CachePut
@CacheEvict


Spring handles Redis automatically.

ğŸ§  Step 1 â€” Enable Caching
1ï¸âƒ£ Add Dependency

If using Maven:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

2ï¸âƒ£ Enable Caching
@SpringBootApplication
@EnableCaching
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}

ğŸ§  Step 2 â€” Use @Cacheable (Main Annotation)

Example:

@Service
public class UserService {

    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        System.out.println("Fetching from DB...");
        return userRepository.findById(id).orElse(null);
    }
}

ğŸ” What happens internally?

First call:

â†’ No cache
â†’ DB called
â†’ Result stored in Redis


Second call:

â†’ Returned from Redis
â†’ DB NOT called


ğŸ”¥ Huge performance boost.

ğŸ§  Step 3 â€” Cache Expiration (TTL Configuration)

By default, cache may not expire.

Add configuration:

@Configuration
public class RedisConfig {

    @Bean
    public RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(5));
    }
}


Now:

Every cached value expires in 5 minutes.

Production tip:
Different caches â†’ different TTL.

ğŸ§  Step 4 â€” Updating Cache
ğŸ”¹ When Data Changes

If you update user:

@CachePut(value = "users", key = "#user.id")
public User updateUser(User user) {
    return userRepository.save(user);
}


@CachePut â†’ updates cache immediately.

ğŸ”¹ Delete Cache
@CacheEvict(value = "users", key = "#id")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}


Very important in real systems.

ğŸš€ PART 2 â€” Redis Pub/Sub in Spring Boot

Now letâ€™s move to real-time messaging.

Spring uses:

RedisTemplate

RedisMessageListenerContainer

MessageListenerAdapter

ğŸ§  Step 1 â€” Publisher
@Autowired
private StringRedisTemplate redisTemplate;

public void sendMessage(String message) {
    redisTemplate.convertAndSend("chat", message);
}


That publishes to channel "chat".

ğŸ§  Step 2 â€” Subscriber
1ï¸âƒ£ Create Listener
@Component
public class RedisSubscriber {

    public void handleMessage(String message) {
        System.out.println("Received message: " + message);
    }
}

2ï¸âƒ£ Configure Listener Container
@Configuration
public class RedisPubSubConfig {

    @Bean
    RedisMessageListenerContainer container(
            RedisConnectionFactory connectionFactory,
            MessageListenerAdapter listenerAdapter) {

        RedisMessageListenerContainer container =
                new RedisMessageListenerContainer();

        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter,
                new PatternTopic("chat"));

        return container;
    }

    @Bean
    MessageListenerAdapter listenerAdapter(RedisSubscriber subscriber) {
        return new MessageListenerAdapter(subscriber, "handleMessage");
    }
}


Now whenever someone publishes to "chat" â†’ subscriber receives it.

ğŸ— Real Production Use Cases
1ï¸âƒ£ Distributed Cache

In microservices:

Service A
Service B
Service C

All share same Redis.

So cache is shared across instances.

2ï¸âƒ£ Distributed Locking

Using Redis to prevent:

Double payment

Double order submission

Race conditions

(Advanced topic: Redisson library)

3ï¸âƒ£ Rate Limiting

Example:
User can only call API 10 times per minute.

Store counter in Redis:

INCR user:123
EXPIRE user:123 60


In Spring â†’ use RedisTemplate.

âš ï¸ Important Interview-Level Concepts
ğŸ”¥ Cache Aside Pattern (Most Important)

Spring Boot uses:

1. Check cache
2. If missing â†’ fetch DB
3. Store in cache
4. Return


This is called:
Cache-Aside Strategy.

ğŸ”¥ Redis Persistence Modes

Redis supports:

RDB (snapshot)

AOF (append-only file)

Even though it's in-memory â†’ it can persist to disk.

ğŸ”¥ Difference: Pub/Sub vs Streams
Feature	Pub/Sub	Streams
Persistence	âŒ No	âœ… Yes
Message history	âŒ No	âœ… Yes
Use case	Real-time	Event processing

For enterprise systems â†’ Streams are more powerful.

ğŸ§  What You Should Practice Now

Since you're already comfortable:

âœ… Practice 1

Create:

GET user API

Use @Cacheable

Add TTL

âœ… Practice 2

Create:

Update user API

Use @CachePut

Use @CacheEvict

âœ… Practice 3

Build:

Simple chat using Pub/Sub