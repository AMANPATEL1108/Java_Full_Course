1Ô∏è‚É£ CTE + Window Functions (Basic Idea)
üîπ Theory (What & Why)

CTE (Common Table Expression) = temporary named result set

Window Function = performs calculation without collapsing rows

Together ‚Üí clean, readable, powerful analytics SQL

Syntax

WITH cte_name AS (
    SELECT ..., window_function() OVER (...)
    FROM table
)
SELECT * FROM cte_name;

2Ô∏è‚É£ Top N Per Group
üîπ Theory

Find top values inside each group

Uses RANK / DENSE_RANK / ROW_NUMBER

PARTITION BY resets ranking per group

‚úÖ Example: Top 2 salaries per department
WITH ranked_emp AS (
    SELECT employee_id,
           department,
           salary,
           DENSE_RANK() OVER (
               PARTITION BY department
               ORDER BY salary DESC
           ) AS rnk
    FROM employees
)
SELECT *
FROM ranked_emp
WHERE rnk <= 2;

üîç Explanation

PARTITION BY department ‚Üí ranking per department

ORDER BY salary DESC ‚Üí highest salary first

rnk <= 2 ‚Üí top 2 per department

3Ô∏è‚É£ Duplicate Removal
üîπ Theory

Used to identify or remove duplicate records

ROW_NUMBER() is best because it creates unique row numbers

‚úÖ Example: Remove duplicate employee_id (keep highest salary)
WITH dedup AS (
    SELECT *,
           ROW_NUMBER() OVER (
               PARTITION BY employee_id
               ORDER BY salary DESC
           ) AS rn
    FROM employees
)
SELECT *
FROM dedup
WHERE rn = 1;

üîç Explanation

PARTITION BY employee_id ‚Üí groups duplicates

ORDER BY salary DESC ‚Üí keeps highest salary

rn = 1 ‚Üí keeps only one row

4Ô∏è‚É£ Trend Analysis
üîπ Theory

Used to compare current row with previous row

Uses LAG() or LEAD()

Common in time-based analysis

‚úÖ Example: Salary change over time
WITH salary_trend AS (
    SELECT employee_id,
           hire_date,
           salary,
           LAG(salary) OVER (
               ORDER BY hire_date
           ) AS prev_salary
    FROM employees
)
SELECT employee_id,
       salary,
       prev_salary,
       salary - prev_salary AS change
FROM salary_trend;

üîç Explanation

LAG(salary) ‚Üí previous salary

Difference shows increase or decrease

No self-join needed

5Ô∏è‚É£ Running Totals
üîπ Theory

Calculates cumulative sum

Common in finance, sales, KPIs

Uses SUM() OVER()

‚úÖ Example: Running salary total by department
WITH running_total AS (
    SELECT department,
           hire_date,
           salary,
           SUM(salary) OVER (
               PARTITION BY department
               ORDER BY hire_date
               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
           ) AS total_salary
    FROM employees
)
SELECT *
FROM running_total;

üîç Explanation

Starts from first row in each department

Adds salary row by row

Shows cumulative growth

üß† Window Function Cheat Sheet
Function	Use
ROW_NUMBER	Unique numbering
RANK	Ranking with gaps
DENSE_RANK	Ranking without gaps
LAG	Previous row
LEAD	Next row
SUM() OVER	Running total

------------------------------------------------Basic Simple Practice Query --------------------------------

WITH cte_name AS (
    SELECT
        customerNumber,
        customerName,
        country,
        creditLimit,
        DENSE_RANK() OVER (
            PARTITION BY country
            ORDER BY creditLimit DESC
        ) AS credit_rank
    FROM customers
)
SELECT *
FROM cte_name;


WITH ranked_customers AS (
    SELECT
        customerNumber,
        customerName,
        country,
        creditLimit,
        DENSE_RANK() OVER (
            PARTITION BY country
            ORDER BY creditLimit DESC
        ) AS rnk
    FROM customers
)
SELECT *
FROM ranked_customers
WHERE rnk <= 2;


WITH ranked_customers AS (
    SELECT
        customerNumber,
        customerName,
        salesRepEmployeeNumber,
        creditLimit,
        DENSE_RANK() OVER (
            PARTITION BY salesRepEmployeeNumber
            ORDER BY creditLimit DESC
        ) AS rnk
    FROM customers
)
SELECT *
FROM ranked_customers
WHERE rnk <= 2;

WITH dedup AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY customerNumber
            ORDER BY creditLimit DESC
        ) AS rn
    FROM customers
)
SELECT *
FROM dedup
WHERE rn = 1;


WITH credit_trend AS (
    SELECT
        customerNumber,
        customerName,
        creditLimit,
        LAG(creditLimit) OVER (
            ORDER BY customerNumber
        ) AS prev_creditLimit
    FROM customers
)
SELECT
    customerNumber,
    customerName,
    creditLimit,
    prev_creditLimit,
    creditLimit - prev_creditLimit AS credit_change
FROM credit_trend;

WITH running_total AS (
    SELECT
        country,
        customerNumber,
        customerName,
        creditLimit,
        SUM(creditLimit) OVER (
            PARTITION BY country
            ORDER BY customerNumber
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS total_credit_limit
    FROM customers
)
SELECT *
FROM running_total;




