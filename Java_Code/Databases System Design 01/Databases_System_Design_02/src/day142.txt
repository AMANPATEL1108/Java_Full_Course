First: What is a transaction? (very important)

A transaction is a group of database operations that should behave like one single action.

Example:

Withdraw money

Update balance

Save transaction record

All of that = one transaction

While a transaction is running:

Other transactions may also be running

This causes conflicts

To manage conflicts, databases use isolation levels.
When isolation is weak â†’ weird things happen.

The â€œweird thingsâ€ are exactly these problems ğŸ‘‡

1ï¸âƒ£ Dirty Read
â€œReading uncommitted dataâ€
Plain English:

You read data that might never become real.

Story Example (Bank)

Initial balance = $100

Transaction T1 (not finished yet)
T1: UPDATE account SET balance = 50


(T1 has NOT committed yet)

Transaction T2 reads:
T2: SELECT balance FROM account â†’ 50


ğŸ’¥ Problem

T2 sees balance = 50

But thenâ€¦

T1 rolls back
T1: ROLLBACK


Balance goes back to $100

âŒ Why this is bad

T2 acted on fake data

That data never officially existed

ğŸ“Œ Dirty Read = reading someone elseâ€™s unfinished work

2ï¸âƒ£ Non-Repeatable Read
â€œSame query â†’ different result in the same transactionâ€
Plain English:

You read a value twice, but it changes while youâ€™re still working.

Story Example (Bank again)

Initial balance = $100

Transaction T1
T1: SELECT balance â†’ 100

Transaction T2 runs and commits
T2: UPDATE account SET balance = 200
T2: COMMIT

T1 reads again
T1: SELECT balance â†’ 200


ğŸ˜µ Same transaction, same query, different result

âŒ Why this is bad

T1 expects data to be stable

Logic breaks (calculations, validations, etc.)

ğŸ“Œ Non-repeatable read = value changes under your feet

3ï¸âƒ£ Phantom Read
â€œNew rows appear between queriesâ€
Plain English:

Rows magically appear or disappear when you run the same query again.

Story Example (Orders)

Orders table:

OrderID | Status
1       | PENDING
2       | PENDING

Transaction T1
T1: SELECT * FROM orders WHERE status = 'PENDING'
â†’ 2 rows

Transaction T2 inserts new row
T2: INSERT INTO orders VALUES (3, 'PENDING')
T2: COMMIT

T1 runs same query again
T1: SELECT * FROM orders WHERE status = 'PENDING'
â†’ 3 rows


ğŸ‘» A phantom appeared

âŒ Why this is bad

Reports become inconsistent

Batch processing breaks

ğŸ“Œ Phantom read = rows appear/disappear unexpectedly

ğŸ”¥ Summary Table (Super Important)
Problem	What changes?	Whatâ€™s weird?
Dirty Read	Uncommitted data	Data never existed
Non-Repeatable Read	Row value	Same row changes
Phantom Read	Number of rows	New rows appear
Practice Time (15 min)

Letâ€™s draw two transactions clearly ğŸ‘‡

ğŸ§ª Dirty Read (Practice)
T1
BEGIN
UPDATE account SET balance = 0

T2
BEGIN
SELECT balance â†’ 0   âŒ

T1
ROLLBACK


ğŸ’¥ T2 used fake data

ğŸ§ª Non-Repeatable Read (Practice)
T1
BEGIN
SELECT balance â†’ 100

T2
UPDATE account SET balance = 150
COMMIT

T1
SELECT balance â†’ 150 âŒ

ğŸ§ª Phantom Read (Practice)
T1
BEGIN
SELECT COUNT(*) WHERE status='PENDING' â†’ 5

T2
INSERT new PENDING order
COMMIT

T1
SELECT COUNT(*) â†’ 6 âŒ


------------------------------------Basic Level of Practice Queries---------------------------------


1ï¸âƒ£ Prevent DIRTY READS

ğŸ‘‰ Use READ COMMITTED (default in most DBs)

âœ… Transaction isolation level
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

Example
BEGIN;

SELECT balance
FROM accounts
WHERE id = 1;

COMMIT;


ğŸ”’ What happens:

SELECT waits if another transaction has an X (exclusive) lock

You never read uncommitted data

ğŸ“Œ Dirty reads are not possible above READ COMMITTED

2ï¸âƒ£ Prevent NON-REPEATABLE READS

ğŸ‘‰ Use REPEATABLE READ or explicit locks

âœ… Option A: Isolation level
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;

SELECT balance
FROM accounts
WHERE id = 1;

-- same value guaranteed
SELECT balance
FROM accounts
WHERE id = 1;

COMMIT;


ğŸ”’ What happens:

Shared lock (or MVCC snapshot) is held

Other transactions cannot change that row

âœ… Option B: Explicit row lock (FOR SHARE)
BEGIN;

SELECT balance
FROM accounts
WHERE id = 1
FOR SHARE;

-- other transactions can read
-- but cannot update this row

COMMIT;


ğŸ“Œ FOR SHARE = shared lock

3ï¸âƒ£ Prevent PHANTOM READS

ğŸ‘‰ Use SERIALIZABLE or range locks

âœ… Option A: SERIALIZABLE (recommended)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN;

SELECT *
FROM orders
WHERE status = 'PENDING';

COMMIT;


ğŸ”’ What happens:

Range / predicate lock

No new PENDING rows can be inserted

âœ… Option B: Explicit locking with FOR UPDATE
BEGIN;

SELECT *
FROM orders
WHERE status = 'PENDING'
FOR UPDATE;

COMMIT;


âš ï¸ Note:

Locks all matching rows

Still may not block new inserts in some DBs

SERIALIZABLE is safer

4ï¸âƒ£ Explicit WRITE lock (very common)
BEGIN;

SELECT *
FROM accounts
WHERE id = 1
FOR UPDATE;

UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

COMMIT;


ğŸ”’ What happens:

Other transactions block

No dirty or non-repeatable reads

ğŸ”¥ Quick Lock Syntax Cheat Sheet
Goal	SQL Syntax
Prevent dirty reads	READ COMMITTED
Prevent non-repeatable reads	REPEATABLE READ
Prevent phantom reads	SERIALIZABLE
Lock row for update	SELECT ... FOR UPDATE
Shared lock (read only)	SELECT ... FOR SHARE
ğŸ§  Database-Specific Notes (Important)
PostgreSQL

Uses MVCC

READ UNCOMMITTED behaves like READ COMMITTED

Supports:

FOR SHARE
FOR UPDATE

MySQL (InnoDB)

Default isolation: REPEATABLE READ

Supports gap locks (for phantom prevention)

SQL Server

Uses locking heavily

Syntax:

SELECT * FROM accounts WITH (UPDLOCK);