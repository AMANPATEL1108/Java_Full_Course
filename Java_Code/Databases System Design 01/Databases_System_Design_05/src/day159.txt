0ï¸âƒ£ What is Aggregation?

In simple words:

Aggregation = Processing data in MongoDB to compute results.

It is used to:

Filter data

Transform documents

Group data

Calculate totals / averages

Join collections

Build reports

Perform analytics

Think of it like:

SQL GROUP BY + WHERE + JOIN + Calculations

But more powerful and flexible

1ï¸âƒ£ Why Do We Need Aggregation?

Normal queries (find()) can:

Filter documents

Project fields

But they cannot:

Group documents

Calculate totals

Perform complex transformations

Join collections (properly)

Create multi-step data pipelines

For that â†’ we use Aggregation Pipeline

2ï¸âƒ£ What is Aggregation Pipeline?

Aggregation works using a pipeline of stages.

Each stage:

Takes input documents

Processes them

Passes results to the next stage

Like a factory assembly line ğŸ­

Collection â†’ Stage 1 â†’ Stage 2 â†’ Stage 3 â†’ Final Result


Basic syntax:

db.collection.aggregate([
   { stage1 },
   { stage2 },
   { stage3 }
])

3ï¸âƒ£ Core Aggregation Stages (Most Important)

Letâ€™s learn the most used stages.

ğŸ”¹ 1. $match (Filtering)

Same as SQL WHERE.

db.orders.aggregate([
   { $match: { status: "completed" } }
])


âœ” Filters documents
âœ” Should be used early for performance

ğŸ”¹ 2. $project (Select / Transform Fields)

Select specific fields or modify them.

db.users.aggregate([
   {
     $project: {
       name: 1,
       age: 1,
       isAdult: { $gte: ["$age", 18] }
     }
   }
])


âœ” Include/exclude fields
âœ” Create new computed fields

ğŸ”¹ 3. $group (Most Important Stage)

Equivalent to SQL GROUP BY.

Example:

db.orders.aggregate([
   {
     $group: {
       _id: "$customerId",
       totalSpent: { $sum: "$amount" },
       avgSpent: { $avg: "$amount" },
       count: { $sum: 1 }
     }
   }
])


Common operators inside $group:

$sum

$avg

$min

$max

$push

$addToSet

$first

$last

ğŸ”¹ 4. $sort

Sort results.

{ $sort: { totalSpent: -1 } }


1 â†’ ascending

-1 â†’ descending

ğŸ”¹ 5. $limit

Limit results.

{ $limit: 5 }

ğŸ”¹ 6. $skip

Skip documents (used for pagination).

{ $skip: 10 }

4ï¸âƒ£ Intermediate Level Stages

Now letâ€™s go deeper.

ğŸ”¹ $lookup (JOIN in MongoDB)

Used to join collections.

Example:

db.orders.aggregate([
   {
     $lookup: {
       from: "customers",
       localField: "customerId",
       foreignField: "_id",
       as: "customerDetails"
     }
   }
])


Equivalent to SQL JOIN.

ğŸ”¹ $unwind (Explode Array)

If a document has an array:

{
   name: "John",
   items: ["pen", "book", "phone"]
}


After $unwind:

{ name: "John", items: "pen" }
{ name: "John", items: "book" }
{ name: "John", items: "phone" }


Example:

{ $unwind: "$items" }

ğŸ”¹ $addFields

Add new fields without removing old ones.

{
   $addFields: {
     totalPrice: { $multiply: ["$price", "$quantity"] }
   }
}

ğŸ”¹ $count

Count documents.

{ $count: "totalDocuments" }

5ï¸âƒ£ Expression Operators (Inside Stages)

Aggregation uses expressions like:

Arithmetic

$add

$subtract

$multiply

$divide

Comparison

$eq

$gt

$gte

$lt

$lte

Logical

$and

$or

$not

Conditional

$cond

$ifNull

$switch

Example:

{
   $project: {
     status: {
       $cond: {
         if: { $gte: ["$score", 50] },
         then: "Pass",
         else: "Fail"
       }
     }
   }
}

6ï¸âƒ£ Advanced Aggregation Concepts

Now we move to advanced topics.

ğŸ”¹ 1. $facet (Multiple Pipelines at Once)

Run multiple aggregations in parallel.

{
  $facet: {
    highValue: [
      { $match: { amount: { $gt: 1000 } } }
    ],
    lowValue: [
      { $match: { amount: { $lte: 1000 } } }
    ]
  }
}

ğŸ”¹ 2. $bucket (Grouping into Ranges)

Group values into ranges.

{
  $bucket: {
    groupBy: "$age",
    boundaries: [0, 18, 30, 50, 100],
    default: "Other",
    output: {
      count: { $sum: 1 }
    }
  }
}

ğŸ”¹ 3. $merge

Write aggregation results into another collection.

{
   $merge: "summaryCollection"
}

ğŸ”¹ 4. $out

Output results to a collection (replaces it).

{
   $out: "newCollection"
}

7ï¸âƒ£ Real-World Example (Full Pipeline)

Letâ€™s say:

We want:

Total sales per customer

Only for completed orders

Sorted by highest spender

Top 3 customers

db.orders.aggregate([
   { $match: { status: "completed" } },
   {
     $group: {
       _id: "$customerId",
       totalSpent: { $sum: "$amount" }
     }
   },
   { $sort: { totalSpent: -1 } },
   { $limit: 3 }
])


Thatâ€™s a real production-level pipeline.

8ï¸âƒ£ Performance Tips (Very Important)

âœ… Always use $match early
âœ… Use indexes on filtered fields
âœ… Avoid unnecessary $project large fields
âœ… Limit array unwinding if possible
âœ… Use $facet carefully (can be heavy)

9ï¸âƒ£ Aggregation vs MapReduce

Old method: MapReduce
Modern & better: Aggregation Framework

âœ” Faster
âœ” Easier
âœ” More readable
âœ” Native support

MapReduce is mostly obsolete now.

ğŸ”Ÿ Interview-Level Knowledge

If you're preparing for interviews, know:

Difference between $project and $addFields

Difference between $push and $addToSet

How $lookup works

When to use $unwind

Pipeline optimization techniques

Handling large datasets

Using indexes in aggregation

ğŸ¯ Final Summary

Aggregation Framework is:

A powerful data processing engine inside MongoDB that works using pipeline stages to transform and compute data.

It allows you to:

Filter

Transform

Group

Join

Analyze

Store results

It replaces complex backend logic with powerful database-side processing.